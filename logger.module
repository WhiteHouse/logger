<?php

/**
 * @file
 * Provides event logging facilities decoupled from storage backend.
 */

/**
 * Implements hook_hook_info_alter().
 */
function logger_hook_info_alter(&$hooks) {
  // Check HOOK.form.inc files for hook_form_alter() implementations.
  $hooks['form_alter']['group'] = 'form';
}

/**
 * Logs a system event.
 *
 * Note: Backends like @link http://graphite.readthedocs.org/ Graphite @endlink
 * interpret dots (.) as path delimiters, like forward slashes (/) in a file
 * path. You need to account for this if part of your event name is dynamically
 * generated and may contain dots. For example:
 *
 * @code
 * $ip_address = str_replace('.', '_', $_SERVER['REMOTE_ADDR']);
 * logger_event(sprintf('server.remote_addr.%s', $ip_address);
 * @endcode
 *
 * @param string $name
 *   The name of the event you want to log.
 * @param string $type
 *   (Optional) The type of metric to log--one of the following values
 *   corresponding to the
 *   @link https://github.com/etsy/statsd/blob/master/docs/metric_types.md StatsD Metric Types @endlink
 *   :
 *   - count: The corresponding value is a number by which to increment (or
 *     decrement, if negative) a simple counter.
 *   - gauge: The corresponding value is a single datum, which remains constant
 *     until explicitly changed.
 *   - set: The corresponding value is a value to add to a set of unique values.
 *   - time: The corresponding value is a duration in milliseconds.
 * @param int $value
 *   (Optional) The numeric value you wish to log. Defaults to 1.
 *
 * @see hook_logger_event()
 */
function logger_event($name, $type = 'count', $value = 1) {
  // Assert valid event type.
  $valid_types = array('count', 'gauge', 'set', 'time');
  if (!in_array($type, $valid_types)) {
    throw new InvalidArgumentException(sprintf('Invalid event type: "%s".', $type));
  }

  // Assert valid event value.
  if (!is_int($value)) {
    throw new InvalidArgumentException(sprintf('Invalid event value: "%s".', $value));
  }

  // Conditionally log events to watchdog for debugging purposes.
  if (variable_get('logger_debug', FALSE)) {
    watchdog('logger', 'Logger Event: @name | @type | @value', array(
      '@name' => $name,
      '@type' => $type,
      '@value' => $value,
    ), WATCHDOG_DEBUG);
  }

  module_invoke_all('logger_event', $name, $type, $value);
}

/**
 * Logs an event at the start of a process.
 *
 * @param string $process_name
 *   The 'process_name' component used in the logger event name.
 * @param string $group
 *   (Optional) The 'group' component used in the logger event name. Defaults to
 *   'logger'.
 */
function logger_log_process_start($process_name, $group = 'logger') {
  // Cleanup existing timers with the same name to prevent accumulation.
  $timer_name = logger_process_timer_name($process_name);
  logger_timer_destroy($timer_name);
  logger_event("processes.{$group}.{$process_name}.invoked");
  timer_start($timer_name);
}

/**
 * Logs an event at the end of a process and the time elapsed.
 *
 * @param string $process_name
 *   The 'process_name' component used in the logger event name.
 * @param string $group
 *   (Optional) The 'group' component used in the logger event name. Defaults to
 *   'logger'.
 * @param string $status
 *   (Optional) The 'status' component used in the logger event name. Defaults
 *   to 'ok'.
 */
function logger_log_process_end($process_name, $group = 'logger', $status = 'ok') {
  $timer_name = logger_process_timer_name($process_name);
  timer_stop($timer_name);
  logger_event("processes.{$group}.{$process_name}.time_to_complete", 'time', (int) timer_read($timer_name));
  logger_event("processes.{$group}.{$process_name}.completed");
  logger_event("processes.{$group}.{$process_name}.statuses.{$status}");
  logger_timer_destroy($timer_name);
}

/**
 * Formats a timer name.
 *
 * @param string $process_name
 *   The name of the process to use in naming the timer.
 *
 * @return string
 *   The formatted timer name.
 */
function logger_process_timer_name($process_name) {
  if (is_string($process_name)) {
    return 'logger_process_timer_' . $process_name;
  }
}

/**
 * Unsets the variable for a given timer.
 *
 * @param string $timer_name
 *   The name of the timer to destroy.
 */
function logger_timer_destroy($timer_name) {
  unset($GLOBALS['timers'][$timer_name]);
}
